## Helper objects and functions

* `promise`, `handle`: promise, coroutine handle associated with a coroutine.

* `awaitable`: result of applying `promise.await_transofrm()` on `co_await`
   expression.

* `awaiter`: result of applying `operator co_await()` on `awaitable`;
   `awaiter == awaitable` if the operator is not provided.

* `SETJMP`, `LONGJMP`: saves/restores coroutine execution context.
   It's worth to note, even though the functions borrow they general meaning
   from `setjmp(3)` and `longjmp(3)` in the context of their usage here, their
   implementation differs substantially (due to stackless character of C++
   coroutines). Whereas standard C library functions save/restore their execution
   context by saving/restoring machine context (e.g. general purpose registers,
   instruction pointer etc.), `SETJMP` and `LONGJMP` base on the specific
   implementation of the coroutine body generated by a compiler as a state
   machine. See [below](#compiler-generated-code) for details.

## Coroutine call pseudo-code

```c++
result_t coroutine_entry(args...)
{
    // Allocate coroutine state on the heap (most cases) or stack (in case of
    // some optimization). coroutine handle is usually 1:1 associated with this
    // state (assumed here). The state is responsible to store coroutine
    // promise object, call parameters, local variables, excecution state.
    //
    // Depending on context it translates to one of the following calls:
    // 1. promise_t::operator new(size);
    // 2. promise_t::operator new(size, args...);
    // 3. ::operator new(size);
    std::coroutine_handle<promise_t> handle = alloc_coroutine_state(size);

    // Copy function parameters into the handle.
    copy_args(handle, args...);

    // Construct local objects in the handle.
    init_locals(handle);

    // Construct promise object in the handle.
    promise_t& promise = init_promise(handle);

    // Get return object representing the coroutine interface for the caller
    result_t result = promise.get_return_object();

    // Run coroutine body provided by the user.
    // The routine returns at coroutine's suspenstion point (co_await returns)
    // or coroutine completion (coroutine_body() returns).
    coroutine_body(handle);

    return result;
}

void coroutine_body(std::coroutine_handle<promise_t> handle)
{
    promise_t& promise = handle.promise();

    // initial suspend (coroutine opening bracket)
    co_await promise.initial_suspend();

    try {
        // coroutine body
        // co_await, co_yield and co_return are inlined as described below
    }
    catch(...) {
        promise.unhandled_exception();
    }

final_suspend:
    // final suspend (coroutine closing bracket)
    co_await promise.final_suspend();

    // In case final_suspend() doesn't suspend, the corutinse is destroyed here.
    // Otherwise std::coroutine_handle::resume() is not possible - coroutine is
    // freed by calling std::coroutine_handle::destroy() by a coroutine's caller.
    //
    // std::coroutine_handle::destroy() frees the coroutine by:
    // 1. Calls the destructor of the promise object.
    // 2. Calls the destructors of the coroutine locals (still in scope).
    // 3. Calls the destructors of the function parameter copies.
    // 4. Calls operator delete (global or promise_t overloaded) to free
    //    the memory used by the coroutine state.
    handle.destroy();
}
```

## `co_await` pseudo-code

Code inlined in `coroutine_body()`:

```c++
if (!awaiter.is_ready())
{
    if (!SETJMP(handle))
    {
        // the coroutine is possible to be resumed via std::coroutine_handle::resume()

        result_t result = awaiter.await_suspend(handle);

        if constexpr (
            (std::is_same_v<result_t, void>) ||
            (std::is_same_v<result_t, bool> && result == true) ||
            (std::is_same_v<result_t, std::noop_coroutine_handle>))
        {
            // Return from coroutine_body().
            // Note, co_await is not yet finished therefore its return value
            // is not yet ready.
            return;
        } else
        if constexpr ((std::is_same_v<result_t, std::coroutine_handle>))
        {
            // In case resuming is done on the current coroutine there is no
            // sense to resume via LONGJMP(), since this has the same effect
            // as leaving current if-statement. This is equivalent to return
            // false by await_suspend() for non-symmetric transfer.
            if (result != handle)
            {
                // Leave current exception handling block and link to the previous
                // one. This way symmetrically resumed coroutine will link with
                // its own exception handler to the handler previous to the
                // current one.
                leave_exception_block();

                // Symmetric transfer: continue by resuming other coroutine.
                // Note a difference between LONGJMP() and std::coroutine_handle::resume()
                // call. In the latter case returning from the other coroutine
                // would finish in the coroutine containing this co_await
                // statement.
                LONGJMP(result);
            }
        }
    }

    // Resume point.
    //
    // Note, the point may be reached not only via call to std::coroutine_handle::resume()
    // but also if await_suspend() returns false or (for symmetric transfer)
    // a handle of current coroutine.
}

// co_await processing finished;
// co_await expression value is ready
auto co_await_result = awaiter.await_resume();
```

## `co_return` pseudo-code

Code inlined in `coroutine_body()`:

```c++
// co_return expr
using expr_t = decltype(expr);

if constexpr (std::is_same_v<expr_t, void>) {
    promise.return_void();
} else {
    promise.return_value(expr);
}

goto final_suspend;
```

## `co_yield`

`co_yield expr` is equivalent to:

```c++
co_await promise.yield_value(expr);
```

## `std::coroutine_handle::resume()`

`std::coroutine_handle::resume()` may be seen as call to `LONGJMP()` inside
a function frame:

```c++
void resume()
{
    LONGJMP(handle);
}
```

Therefore `std::coroutine_handle::resume()` returns in case `coroutine_body()`
returns. That is on `co_await` return or if coroutine reaches its completion.

NOTE: This is conceptual pseudo-code. Actual code generated by a compiler bases
on coroutine-as-a-state-machine implementation as described below.

## Compiler generated code

Basing on `gcc-10` [reverse engineered coroutine code](disasm/notes.disasm),
`coroutine_body()` function generated by the compiler may be presented as the
following state machine:

```c++
switch(handle.state)
{
// entry state
case AWAIT_INITIAL:
    // code for co_await Promise::initial_suspend()
    ...
    // if initially suspended return to the caller
    return;
    // otherwise change state to AWAIT_INITIAL_RESUME
    handle.state = AWAIT_INITIAL_RESUME;
    goto AWAIT_INITIAL_RESUME;

// coroutine destroyed at initial suspend
case AWAIT_INITIAL_DESTROY:
    goto destroy;

// coroutine initially resumed
case AWAIT_INITIAL_RESUME:
    // code up to the subsequent co_await statement(s)
    // finishes by return or move to the next state as for AWAIT_INITIAL
    ...

// N-th co_await resume and destroy state
case AWAIT_N_DESTROY:
    goto destroy;
case AWAIT_N_RESUME:
    ...

// final suspension (resume is not allowed)
case AWAIT_FINAL_DESTROY:
    goto destroy;
}

destroy:
// coroutine destroy code
...
```

As may be seen coroutine suspension (`SETJMP()`), resume (`LONGJMP()`) and
destroy is done by leaving and entering `coroutine_body()` with appropriate
state set.

Note, since the coroutine local variables are preserved on a separate space on
the heap (coroutine state), they are not affected by coroutine's execution stack
frame unwinding at `coroutine_body()` exit.
